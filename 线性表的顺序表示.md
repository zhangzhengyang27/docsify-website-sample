#### 1、顺序表中删除具有最小值的元素

 从顺序表中删除具有最小值的元素（假设唯一），并由函数返回被删除元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行

算法的思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的最小元素的位置

```c++
bool Del_min(sqList &L,ElemType &value){
    // 删除顺序表L中最小值元素节点，并通过引用型参数value返回其值
    // 如果删除成功，返回true;否则，返回false
    if(L.length==0){
        return false
    }
    value=L.data[0];
    int pos=0;
    for(int i=1;i<L.length;i++){
        if(L.data[i]<value){
            value=L.data[i]
            pos=i;
        }
    }
    L.data[pos]=L.data[L.length-1];
    L.length--;
    return true
}
```

#### 2、设计一个高效的算法，将顺序表的所有元素逆置，要求算法的空间复杂度为O(1)

```c++
void Reverse(Sqlist &L){
    Elemtype temp;
    for(i=0;i<L.length/2;i++){
        temp=L.data[i];
        L.data[i]=L.data[L.length-i-1];
        L.data[L.length-i-1]=temp;
    }
}
```

